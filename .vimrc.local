"soruby
"colorscheme soruby
colorscheme onedark
set guifont=Menlo:h18

set encoding=utf-8
set termencoding=utf-8
set fileencoding=utf-8
set fileencodings=UCS-bom,utf-8,gb18030,gbk,latin1

set ignorecase
set smartcase
set nospell

language messages zh_CN.utf-8

au BufNewFile,BufRead *.groovy  setf groovy

let mapleader = ","
let g:mapleader = ","
let g:C_MapLeader=","

if has("gui_running")
    "windowså‰ªåˆ‡æ¿è®¾ä¸ºé»˜è®¤å¯„å­˜å™¨
    set clipboard+=unnamed

    "æ·»åŠ æ°´å¹³æ»šåŠ¨æ¡
    set guioptions+=b
endif

"airblade/vim-gitgutter æ’ä»¶ åœ¨gitæ–‡ä»¶ä¸­è‡ªåŠ¨æ˜¾ç¤ºä¿®æ”¹
"set updatetime=250
let g:gitgutter_enabled = 0
"Xuyuanp/nerdtree-git-plugin æ’ä»¶ï¼Œåœ¨NERDTreeæ’ä»¶ä¸­æ˜¾ç¤ºgitæ–‡ä»¶çŠ¶æ€
let g:NERDTreeIndicatorMapCustom = {
    \ "Modified"  : "*",
    \ "Staged"    : "+",
    \ "Untracked" : "â˜†",
    \ "Renamed"   : "â†’",
    \ "Unmerged"  : "â•",
    \ "Deleted"   : "Ã—",
    \ "Dirty"     : "â€»",
    \ "Clean"     : "âˆš",
    \ "Unknown"   : "?"
    \ }

"è‡ªåŠ¨ä¿å­˜æ–‡ä»¶
"set autowriteall

"hi cursorline guifg=magenta cyan orange purple violet seagreen slateblue darkred

"jsonæ–‡ä»¶æ ¼å¼åŒ–
nnoremap <unique><silent> <leader>jf :call FormatJson()<cr>
"xmlæ–‡ä»¶æ ¼å¼åŒ–ï¼Œéœ€è¦libxml2æ”¯æŒï¼Œåœ¨ç™¾åº¦äº‘ç›˜ä¸­æœ‰
nnoremap <unique><silent> <leader>xf :call FormatXml()<cr>
nnoremap <unique><silent> <leader>xi :%!xmllint --encode utf8 --pretty 1 --recover - 2>/dev/null<cr>
vnoremap <unique><silent> <leader>xi :!xmllint --encode utf8 --pretty 1 --recover - 2>/dev/null<cr>
vnoremap <unique><silent> <leader>fp :call FormatPrivate()<cr>
nnoremap <unique><silent> <leader>fp :call FormatPrivate()<cr>
vnoremap <unique><silent> <leader>fr :call FormatResponse()<cr>
vnoremap <unique><silent> <leader>fm :call FormatMapper()<cr>

" :help indent-guides
nmap <silent> <Leader>ig <Plug>IndentGuidesToggle
nmap <silent> <Leader>ie <Plug>IndentGuidesEnable
nmap <silent> <Leader>id <Plug>IndentGuidesDisable

" easymotionæ’ä»¶
" å¿½ç•¥å¤§å°å†™
let g:EasyMotion_smartcase = 1
nmap ss <Plug>(easymotion-s2)

" TRADER_NAME	å•†æˆ·åç§°
" -->
" // å•†æˆ·åç§°
" @JsonProperty("TRADER_NAME")
" private String traderName;
" 0f	d$O// pV:s/\t//gjyypkI@JsonProperty("lxxA")jVuV:s/_\(.\)/\u\1/geIprivate String A;j0

" active_time	ç”Ÿæ•ˆæ—¶é—´
" -->
" // ç”Ÿæ•ˆæ—¶é—´
" @Column(name = "active_time")
" private String activeTime;
" 0f	r d$O//pjyypV:s/_\([a-z]\)/\u\1/geki@Column(Â€krÂ€kbname = "Â€krÂ€kbA")jIprivate String A;j
nmap <F1> :tabnew
nmap <F2> :tabprevious<CR>
nmap <F3> :tabnext<CR>
nnoremap <silent> <F4> :TagbarToggle<CR>
nnoremap <F5> :UndotreeToggle<cr>
vnoremap <C-c> y
inoremap <C-v> <esc>:set paste<cr>a<C-R>+<esc>:set nopaste<cr>



"Rainbow å¯¹xmlæ ¼å¼åŒ–æœ‰å½±å“
"let g:rainbow_active = 0
"let g:rainbow_conf = {
"    \   'guifgs': ['royalblue3', 'darkorange3', 'seagreen3', 'firebrick'],
"    \   'ctermfgs': ['lightblue', 'lightyellow', 'lightcyan', 'lightmagenta'],
"    \   'operators': '_,_',
"    \   'parentheses': ['start=/(/ end=/)/ fold', 'start=/\[/ end=/\]/ fold', 'start=/{/ end=/}/ fold'],
"    \   'separately': {
"    \       '*': {},
"    \       'tex': {
"    \           'parentheses': ['start=/(/ end=/)/', 'start=/\[/ end=/\]/'],
"    \       },
"    \       'lisp': {
"    \           'guifgs': ['royalblue3', 'darkorange3', 'seagreen3', 'firebrick', 'darkorchid3'],
"    \       },
"    \       'vim': {
"    \           'parentheses': ['start=/(/ end=/)/', 'start=/\[/ end=/\]/', 'start=/{/ end=/}/ fold', 'start=/(/ end=/)/ containedin=vimFuncBody', 'start=/\[/ end=/\]/ containedin=vimFuncBody', 'start=/{/ end=/}/ fold containedin=vimFuncBody'],
"    \       },
"    \       'html': {
"    \           'parentheses': ['start=/\v\<((area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)[ >])@!\z([-_:a-zA-Z0-9]+)(\s+[-_:a-zA-Z0-9]+(\=("[^"]*"|'."'".'[^'."'".']*'."'".'|[^ '."'".'"><=`]*))?)*\>/ end=#</\z1># fold'],
"    \       },
"    \       'css': 0,
"    \   }
"    \}


function FormatXml() range
    " Locate block of code to be considered (same indentation, no blanks)
    let l:firstline  = search('^\%(.\)\@!','bnW') + 1
    let l:lastline   = search('^\%(.\)\@!', 'nW') - 1
    if l:lastline < 0
        let l:lastline = line('$')
    endif
    "<aaa><cr><bbb>
    exec l:firstline . "," . l:lastline . 's/<[-_:A-z0-9]\+>\(\s*<[-_:A-z0-9]\+>\)\@=/&\r/ge'

    " Locate block of code to be considered (same indentation, no blanks)
    let l:firstline  = search('^\%(.\)\@!','bnW') + 1
    let l:lastline   = search('^\%(.\)\@!', 'nW') - 1
    if l:lastline < 0
        let l:lastline = line('$')
    endif
    "</aaa><cr>
    exec l:firstline . "," . l:lastline . 's,</[-_:A-z0-9]\+>\s*\($\)\@!,&\r,ge'

    " Locate block of code to be considered (same indentation, no blanks)
    let l:firstline  = search('^\%(.\)\@!','bnW') + 1
    let l:lastline   = search('^\%(.\)\@!', 'nW') - 1
    if l:lastline < 0
        let l:lastline = line('$')
    endif
    "><cr><aaa/>
    exec l:firstline . "," . l:lastline . 's,\(>\)\@<=\s*<[-_:A-z0-9]\+/>,\r&,ge'

    " Locate block of code to be considered (same indentation, no blanks)
    let l:firstline  = search('^\%(.\)\@!','bnW') + 1
    let l:lastline   = search('^\%(.\)\@!', 'nW') - 1
    if l:lastline < 0
        let l:lastline = line('$')
    endif
    "<aaa/><cr><
    exec l:firstline . "," . l:lastline . 's,<[-_:A-z0-9]\+/>\s*\(<\)\@=,&\r,ge'

    " Locate block of code to be considered (same indentation, no blanks)
    let l:firstline  = search('^\%(.\)\@!','bnW') + 1
    let l:lastline   = search('^\%(.\)\@!', 'nW') - 1
    if l:lastline < 0
        let l:lastline = line('$')
    endif
    "ä½¿ç”¨xmllintæ ¼å¼åŒ–
    exec l:firstline . "," . l:lastline . '!xmllint --encode utf8 --pretty 1 --recover - 2>/dev/null'
endfunction

function FormatJson() range
    " Locate block of code to be considered (same indentation, no blanks)
    let l:firstline  = search('^\%(.\)\@!','bnW') + 1
    let l:lastline   = search('^\%(.\)\@!', 'nW') - 1
    if l:lastline < 0
        let l:lastline = line('$')
    endif
    ", => ,<cr>
    exec l:firstline . "," . l:lastline . 's/,\($\)\@!/,\r/ge'

    " Locate block of code to be considered (same indentation, no blanks)
    let l:firstline  = search('^\%(.\)\@!','bnW') + 1
    let l:lastline   = search('^\%(.\)\@!', 'nW') - 1
    if l:lastline < 0
        let l:lastline = line('$')
    endif
    "key=value] => key=value<cr>]
    exec l:firstline . "," . l:lastline . 's/^[^{\[\]}]\+\([\]}]\)\@=/&\r/ge'

    " Locate block of code to be considered (same indentation, no blanks)
    let l:firstline  = search('^\%(.\)\@!','bnW') + 1
    let l:lastline   = search('^\%(.\)\@!', 'nW') - 1
    if l:lastline < 0
        let l:lastline = line('$')
    endif
    "^[... => [<cr>]
    exec l:firstline . "," . l:lastline . 's/^[{\[]\([}\],$]\)\@!/&\r/ge'

    " Locate block of code to be considered (same indentation, no blanks)
    let l:firstline  = search('^\%(.\)\@!','bnW') + 1
    let l:lastline   = search('^\%(.\)\@!', 'nW') - 1
    if l:lastline < 0
        let l:lastline = line('$')
    endif
    "...[... => ...[<cr>
    exec l:firstline . "," . l:lastline . 'g/[^\]}]/s/[^\[{][\[{]\([}\]$]\)\@!/&\r/ge'

    " Locate block of code to be considered (same indentation, no blanks)
    let l:firstline  = search('^\%(.\)\@!','bnW') + 1
    let l:lastline   = search('^\%(.\)\@!', 'nW') - 1
    if l:lastline < 0
        let l:lastline = line('$')
    endif
    "[[... => [<cr>[
    exec l:firstline . "," . l:lastline . 's/[\[{][^\[{]*\([\[{]\)\@=/&\r/ge'

    " Locate block of code to be considered (same indentation, no blanks)
    let l:firstline  = search('^\%(.\)\@!','bnW') + 1
    let l:lastline   = search('^\%(.\)\@!', 'nW') - 1
    if l:lastline < 0
        let l:lastline = line('$')
    endif
    "]] => ]<cr>]
    exec l:firstline . "," . l:lastline . 's/[\]}][^\]}]*\([\]}]\)\@=/&\r/ge'

    " Locate block of code to be considered (same indentation, no blanks)
    let l:firstline  = search('^\%(.\)\@!','bnW') + 1
    let l:lastline   = search('^\%(.\)\@!', 'nW') - 1
    if l:lastline < 0
        let l:lastline = line('$')
    endif
    "[..., => [<cr>...,
    exec l:firstline . "," . l:lastline . 's/\([\[{]\)\@<=[^\]}]*,\@=/\r&/ge'

"    " èµ·æ‹¬å·åœ¨åŒä¸€è¡Œè¿˜æ˜¯æ¢è¡Œ
"    let l:firstline  = search('^\%(.\)\@!','bnW') + 1
"    let l:lastline   = search('^\%(.\)\@!', 'nW') - 1
"    if l:lastline < 0
"        let l:lastline = line('$')
"    endif
"    "=[ => =<cr>[
"    exec l:firstline . "," . l:lastline . 's/\([:=]\)\([\[{]$\)/\1\r\2/ge'

    " Locate block of code to be considered (same indentation, no blanks)
    let l:firstline  = search('^\%(.\)\@!','bnW') + 1
    let l:lastline   = search('^\%(.\)\@!', 'nW') - 1
    if l:lastline < 0
        let l:lastline = line('$')
    endif
    let l:centline = l:lastline - l:firstline
    exec l:firstline
    let l:save_ft = &filetype
    set filetype=json
    exec "normal " . l:centline . "=="
    let &filetype=l:save_ft
endfunction



function FormatPrivate() range
    let top = a:firstline
    let size = a:lastline - a:firstline + 1
    while size > 0
        exe top . "," . top . 'normal 0/[ \t]d$O//p0llr jVuV:s/_\([a-z]\)/\u\1/egIprivate String A;j0'
        let size -= 1
        let top += 2
    endwhile
endfunction


function FormatResponse() range
    let top = a:firstline
    let size = a:lastline - a:firstline + 1
    while size > 0
        exe top . "," . top . 'normal yypkVuV:s/_\(.\)/\u\1/egIthis.A = (StringJacontent.get(lxi"lxA");j'
        let size -= 1
        let top += 1
    endwhile
endfunction

function FormatMapper() range
    let top = a:firstline
    let size = a:lastline - a:firstline + 1
    while size > 0
        exe top . "," . top . 'normal yypkVuV:s/_\(.\)/\u\1/egI<rule source="lxA" target="lxJxA"/>j'
        let size -= 1
        let top += 1
    endwhile
endfunction
