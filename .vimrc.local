colorscheme soruby
set guifont=Consolas:h14

set encoding=utf-8
set termencoding=utf-8
set fileencoding=utf-8
set fileencodings=UCS-bom,utf-8,gb18030,gbk,latin1

language messages zh_CN.utf-8

let mapleader = ","
let g:mapleader = ","
let g:C_MapLeader=","

"windows剪切板设为默认寄存器
set clipboard+=unnamed

"添加水平滚动条
set guioptions+=b

"hi cursorline guifg=magenta cyan orange purple violet seagreen slateblue darkred

"json文件格式化
nnoremap <unique><silent> <leader>jf :call FormatJson()<cr>
"xml文件格式化，需要libxml2支持，在百度云盘中有
nnoremap <unique><silent> <leader>xf :call FormatXml()<cr>
nnoremap <unique><silent> <leader>xi :%!xmllint --encode utf8 --pretty 1 --recover - 2>/dev/null<cr>
vnoremap <unique><silent> <leader>xi :!xmllint --encode utf8 --pretty 1 --recover - 2>/dev/null<cr>


nmap <F1> :tabnew
nmap <F2> :tabprevious<CR>
nmap <F3> :tabnext<CR>
nnoremap <silent> <F4> :TagbarToggle<CR>


"Rainbow 对xml格式化有影响
"let g:rainbow_active = 0
"let g:rainbow_conf = {
"    \   'guifgs': ['royalblue3', 'darkorange3', 'seagreen3', 'firebrick'],
"    \   'ctermfgs': ['lightblue', 'lightyellow', 'lightcyan', 'lightmagenta'],
"    \   'operators': '_,_',
"    \   'parentheses': ['start=/(/ end=/)/ fold', 'start=/\[/ end=/\]/ fold', 'start=/{/ end=/}/ fold'],
"    \   'separately': {
"    \       '*': {},
"    \       'tex': {
"    \           'parentheses': ['start=/(/ end=/)/', 'start=/\[/ end=/\]/'],
"    \       },
"    \       'lisp': {
"    \           'guifgs': ['royalblue3', 'darkorange3', 'seagreen3', 'firebrick', 'darkorchid3'],
"    \       },
"    \       'vim': {
"    \           'parentheses': ['start=/(/ end=/)/', 'start=/\[/ end=/\]/', 'start=/{/ end=/}/ fold', 'start=/(/ end=/)/ containedin=vimFuncBody', 'start=/\[/ end=/\]/ containedin=vimFuncBody', 'start=/{/ end=/}/ fold containedin=vimFuncBody'],
"    \       },
"    \       'html': {
"    \           'parentheses': ['start=/\v\<((area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)[ >])@!\z([-_:a-zA-Z0-9]+)(\s+[-_:a-zA-Z0-9]+(\=("[^"]*"|'."'".'[^'."'".']*'."'".'|[^ '."'".'"><=`]*))?)*\>/ end=#</\z1># fold'],
"    \       },
"    \       'css': 0,
"    \   }
"    \}


function FormatXml() range
    " Locate block of code to be considered (same indentation, no blanks)
    let l:firstline  = search('^\%(.\)\@!','bnW') + 1
    let l:lastline   = search('^\%(.\)\@!', 'nW') - 1
    if l:lastline < 0
        let l:lastline = line('$')
    endif
    "<aaa><cr><bbb>
    exec l:firstline . "," . l:lastline . 's/<[-_:A-z0-9]\+>\(\s*<[-_:A-z0-9]\+>\)\@=/&\r/ge'

    " Locate block of code to be considered (same indentation, no blanks)
    let l:firstline  = search('^\%(.\)\@!','bnW') + 1
    let l:lastline   = search('^\%(.\)\@!', 'nW') - 1
    if l:lastline < 0
        let l:lastline = line('$')
    endif
    "</aaa><cr>
    exec l:firstline . "," . l:lastline . 's,</[-_:A-z0-9]\+>\s*\($\)\@!,&\r,ge'

    " Locate block of code to be considered (same indentation, no blanks)
    let l:firstline  = search('^\%(.\)\@!','bnW') + 1
    let l:lastline   = search('^\%(.\)\@!', 'nW') - 1
    if l:lastline < 0
        let l:lastline = line('$')
    endif
    "><cr><aaa/>
    exec l:firstline . "," . l:lastline . 's,\(>\)\@<=\s*<[-_:A-z0-9]\+/>,\r&,ge'

    " Locate block of code to be considered (same indentation, no blanks)
    let l:firstline  = search('^\%(.\)\@!','bnW') + 1
    let l:lastline   = search('^\%(.\)\@!', 'nW') - 1
    if l:lastline < 0
        let l:lastline = line('$')
    endif
    "<aaa/><cr><
    exec l:firstline . "," . l:lastline . 's,<[-_:A-z0-9]\+/>\s*\(<\)\@=,&\r,ge'

    " Locate block of code to be considered (same indentation, no blanks)
    let l:firstline  = search('^\%(.\)\@!','bnW') + 1
    let l:lastline   = search('^\%(.\)\@!', 'nW') - 1
    if l:lastline < 0
        let l:lastline = line('$')
    endif
    "使用xmllint格式化
    exec l:firstline . "," . l:lastline . '!xmllint --encode utf8 --pretty 1 --recover - 2>/dev/null'
endfunction

function FormatJson() range
    " Locate block of code to be considered (same indentation, no blanks)
    let l:firstline  = search('^\%(.\)\@!','bnW') + 1
    let l:lastline   = search('^\%(.\)\@!', 'nW') - 1
    if l:lastline < 0
        let l:lastline = line('$')
    endif
    exec l:firstline . "," . l:lastline . 's/,\($\)\@!/,\r/ge'

    " Locate block of code to be considered (same indentation, no blanks)
    let l:firstline  = search('^\%(.\)\@!','bnW') + 1
    let l:lastline   = search('^\%(.\)\@!', 'nW') - 1
    if l:lastline < 0
        let l:lastline = line('$')
    endif
    "key=value] => key=value<cr>]
    exec l:firstline . "," . l:lastline . 's/^[^{\[\]}]\+\([\]}]\)\@=/&\r/ge'

    " Locate block of code to be considered (same indentation, no blanks)
    let l:firstline  = search('^\%(.\)\@!','bnW') + 1
    let l:lastline   = search('^\%(.\)\@!', 'nW') - 1
    if l:lastline < 0
        let l:lastline = line('$')
    endif
    "^[... => [<cr>]
    exec l:firstline . "," . l:lastline . 's/^[{\[]\($\)\@!/&\r/ge'

    " Locate block of code to be considered (same indentation, no blanks)
    let l:firstline  = search('^\%(.\)\@!','bnW') + 1
    let l:lastline   = search('^\%(.\)\@!', 'nW') - 1
    if l:lastline < 0
        let l:lastline = line('$')
    endif
    "...[... => ...[<cr>
    exec l:firstline . "," . l:lastline . 'g/[^\]}]/s/[^\[{][\[{]\($\)\@!/&\r/ge'

    " Locate block of code to be considered (same indentation, no blanks)
    let l:firstline  = search('^\%(.\)\@!','bnW') + 1
    let l:lastline   = search('^\%(.\)\@!', 'nW') - 1
    if l:lastline < 0
        let l:lastline = line('$')
    endif
    "[[... => [<cr>[
    exec l:firstline . "," . l:lastline . 's/[\[{][^\[{]*\([\[{]\)\@=/&\r/ge'

    " Locate block of code to be considered (same indentation, no blanks)
    let l:firstline  = search('^\%(.\)\@!','bnW') + 1
    let l:lastline   = search('^\%(.\)\@!', 'nW') - 1
    if l:lastline < 0
        let l:lastline = line('$')
    endif
    "]] => ]<cr>]
    exec l:firstline . "," . l:lastline . 's/[\]}][^\]}]*\([\]}]\)\@=/&\r/ge'

    " Locate block of code to be considered (same indentation, no blanks)
    let l:firstline  = search('^\%(.\)\@!','bnW') + 1
    let l:lastline   = search('^\%(.\)\@!', 'nW') - 1
    if l:lastline < 0
        let l:lastline = line('$')
    endif
    let l:centline = l:lastline - l:firstline
    exec l:firstline
    let l:save_ft = &filetype
    set filetype=json
    exec "normal " . l:centline . "=="
    let &filetype=l:save_ft
endfunction
